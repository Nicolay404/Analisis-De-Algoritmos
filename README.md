<h1 align="center"> ANÁLISIS DE ALGORITMOS <img src="https://media.giphy.com/media/hvRJCLFzcasrR4ia7z/giphy.gif" width="35"></h1>

<div align="center">
  <img src="https://media1.giphy.com/media/v1.Y2lkPTc5MGI3NjExcXN4aGx2ZjVnc2w5emJ2dXdyYm9panEwdWxmN2Z4dXZ4NDVwaGg5eSZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/78XCFBGOlS6keY1Bil/giphy.gif" width="300">
</div>

<h3></strong> <em>Diego Nicolay Jiménez Carrión - 💎</em></h3>

<hr>

<div align="left">
  <p>
    ▶️ El análisis de algoritmos y la algoritmia son pilares fundamentales en el campo de la informática y la ciencia de la computación. 
    Ambos conceptos se centran en el estudio de los algoritmos: secuencias ordenadas de pasos que permiten resolver problemas, 
    realizar tareas o efectuar cálculos de manera eficiente.
  </p>

  <p>
    💨 En esta wiki se abordarán de forma estructurada todos los temas relacionados con el análisis de algoritmos, explorando desde 
    conceptos básicos hasta técnicas avanzadas. El objetivo es proporcionar una guía completa y accesible que facilite la comprensión 
    y aplicación de los principios que sustentan este amplio y esencial campo de estudio. 👀
  </p>
</div>

<!-- INICIO DEL INDICE -->

<!-- FIN DEL INDICE --->

<!-- INICIO DEL CONTENIDO -->
  <h1>📚 ALGORITMOS Y ANÁLISIS</h1>

  <section>
    <h2>⚙️ ¿Qué es un algoritmo?</h2>
    <p>
      Un <strong>algoritmo</strong> es un conjunto de instrucciones o reglas definidas para ejecutar algún cálculo, ya sea manualmente o mediante una máquina. Transforma un estado inicial y una entrada en un estado final mediante pasos sucesivos.
    </p>
    <blockquote>
      <strong>Ejemplo:</strong> Encender la luz de una habitación.<br><br>
      ¿La luz está apagada?<br>
      <strong>NO:</strong> FIN<br>
      <strong>SÍ:</strong> Ve al paso 2<br>
      ——<br>
      Presiona el interruptor y vuelve al paso 1.
    </blockquote>
    <p>
      Los algoritmos permiten la automatización digital moderna y son esenciales en disciplinas como las matemáticas, la informática y la lógica. Por ejemplo, un algoritmo puede resolver problemas tan simples como ordenar una lista de números o tan complejos como predecir el clima.
    </p>
  </section>

  <section>
    <h2>✨ Características</h2>
    <ul>
      <li><strong>🔁 Secuenciales:</strong> Procesan paso a paso.</li>
      <li><strong>🎯 Precisos:</strong> Instrucciones claras y específicas.</li>
      <li><strong>🧾 Ordenados:</strong> Se siguen en un orden lógico.</li>
      <li><strong>⛔ Finitos:</strong> Tienen inicio y fin.</li>
      <li><strong>📌 Definidos:</strong> Mismos resultados con mismas entradas.</li>
    </ul>
  </section>

  <section>
    <h2>🧩 Partes de un algoritmo</h2>
    <ul>
      <li><strong>📥 Entrada (Input):</strong> Instrucciones iniciales.</li>
      <li><strong>⚙️ Proceso:</strong> Operaciones lógicas.</li>
      <li><strong>📤 Salida (Output):</strong> Resultados finales.</li>
    </ul>
<p align="center">  <img src="https://github.com/user-attachments/assets/8454721e-38df-4e67-83e6-b10d8117fa76" alt="Partes del algoritmo" width=300></p>

  </section>

  <section>
    <h2>🧠 ALGORITMIA</h2>
    <p>
      La <strong>algoritmia</strong> estudia los algoritmos, enfocándose en su diseño, análisis y aplicación para resolver problemas de manera eficiente. Es una disciplina clave en informática que busca optimizar recursos computacionales.
    </p>
  <p align="center"> 
  <img src="https://github.com/user-attachments/assets/9020c530-f3e6-4f66-a0d6-f31eaa4123db" alt="Algoritmia"  width=300> </p>
  </section>

  <section>
    <h2>🔍 Análisis de algoritmos</h2>
    <p>
      Estudia la <strong>complejidad computacional</strong>, estimando recursos como tiempo y almacenamiento. Permite comparar soluciones independientemente del lenguaje de programación utilizado.
    </p>
    <h3>📊 Tipos de casos</h3>
    <ul>
      <li><strong>🟢 Mejor caso:</strong> Mínimo número de pasos.</li>
      <li><strong>🟡 Caso promedio:</strong> Pasos esperados.</li>
      <li><strong>🔴 Peor caso:</strong> Máximo número de pasos.</li>
    </ul>

    
## 📊 Complejidad Computacional

La **complejidad computacional** se refiere al análisis del **tiempo** y **espacio** que requiere un algoritmo para ejecutarse. Esto implica medir los recursos que utiliza:

- ⏳ **Tiempo:** duración de la ejecución del algoritmo.  
- 💾 **Memoria:** cantidad de almacenamiento necesaria para completar el proceso.


---

### 📌 Ejemplo Comparativo

| Algoritmo           | Pasos en promedio |
|---------------------|-------------------|
| 🔍 Búsqueda lineal   | 28 pasos          |
| ⚡ Búsqueda binaria  | 5 pasos           |

---

Este análisis es relevante porque permite **optimizar el rendimiento** de los algoritmos, asegurando que sean **más rápidos** y **eficientes** en el uso de recursos. 🚀

  </section>

  <section>
    <h2>🔎 Tipos de análisis</h2>
    <ul>
      <li><strong>⏱️ Complejidad temporal:</strong> Relación con el tamaño de entrada.</li>
      <li><strong>🧠 Complejidad espacial:</strong> Memoria usada.</li>
      <li><strong>✅ Correctitud:</strong> Verifica salidas correctas.</li>
      <li><strong>📈 Asintótico:</strong> Comportamiento con entradas grandes.</li>
    </ul>
  </section>
<br/>
<br/>
<h2> DESARROLLO DE CONTENIDOS</h2>
<!---------------------------------------------------- SEMANA 1 --------------------------------------------------->
<details>
  <summary><h2>📌 SEMANA 1</h2></summary>
  <h2>🌱 1. Algoritmia elemental</h2>
    <p>
      Introduce conceptos básicos como eficiencia, análisis de casos y algoritmos simples (búsqueda lineal, binaria, ordenamientos). Por ejemplo, la búsqueda lineal recorre todos los elementos hasta encontrar el objetivo, mientras que la búsqueda binaria divide el espacio de búsqueda a la mitad en cada paso, siendo más eficiente en listas ordenadas.
    </p>
  </section>

  <section>
    <h2>📌 1.1 Preliminares</h2>
    <ul>
      <li>Definición de algoritmo</li>
      <li>Representación: pseudocódigo, diagramas de flujo</li>
      <li>Análisis del problema, diseño y prueba</li>
    </ul>
  </section>

  <section>
    <h2>🔤 1.1.1 Notación</h2>
    <ul>
      <li><strong>O grande (O):</strong> Cota superior. Representa el peor caso de crecimiento, ignorando constantes y términos menores. Ejemplo: O(n²) para un algoritmo que realiza operaciones cuadráticas.</li>
      <li><strong>Omega (ω):</strong> Cota inferior. Indica el mejor caso de crecimiento. Ejemplo: ω(n) para un algoritmo que al menos recorre una lista una vez.</li>
      <li><strong>Theta (θ):</strong> Cota ajustada. Describe un crecimiento exacto, combinando O y ω. Ejemplo: θ(n log n) para algoritmos como Quicksort en el caso promedio.</li>
    </ul>
   <p align="center">  <img src="https://i.ytimg.com/vi/Qui-iOPdhLI/maxresdefault.jpg" alt="Notación asintótica" width=400> </p>
  </section>

  <section>
    <h2>🚫 1.1.2 Contradicción</h2>
    <p>
      Técnica para demostrar afirmaciones asumiendo lo contrario y llegando a un error lógico. Por ejemplo, para demostrar que √2 es irracional, se asume que es racional (√2 = a/b) y se llega a una contradicción al mostrar que a y b deben ser ambos pares, lo que es imposible.
    </p>
  </section>

  <section>
    <h2>📐 1.1.3 Inducción matemática</h2>
    <p>
      Técnica de prueba que utiliza un caso base y un paso inductivo. Ejemplo clásico: Probar que <code>1 + 2 + ... + n = n(n+1)/2</code>.
    </p>
    <p>
      <strong>Caso base:</strong> Para n = 1, 1 = 1(1+1)/2 = 1. Se cumple.<br>
      <strong>Paso inductivo:</strong> Asumimos que es cierto para n = k, es decir, 1 + 2 + ... + k = k(k+1)/2. Para n = k+1, sumamos k+1 a ambos lados: 1 + 2 + ... + k + (k+1) = k(k+1)/2 + (k+1) = (k+1)(k+2)/2. Se cumple.<br>
      Por lo tanto, la fórmula es válida para todo n.
    </p>
  </section>
</details>
  <section>
    
<!---------------------------------------------------- SEMANA 2 --------------------------------------------------->
  <details>
  <summary><h2>📌 SEMANA 2</h2></summary>
   <section>
    <h2>⚡ 1.2 Eficiencia de los algoritmos</h2>
    <ul>
      <li><strong>⏳ Tiempo de ejecución:</strong> Operaciones según entrada. Por ejemplo, un algoritmo O(n) tarda el doble si la entrada se duplica.</li>
      <li><strong>💾 Uso de memoria:</strong> Variables, estructuras, temporales. Un algoritmo recursivo puede usar más memoria debido a la pila de llamadas.</li>
      <li><strong>📊 Complejidad computacional:</strong> Representación matemática de la eficiencia, como O(log n) para búsqueda binaria.</li>
    </ul>
    <p><strong>Métodos:</strong> Teórico (matemático) y empírico (con pruebas reales). El análisis teórico predice el comportamiento, mientras que el empírico mide tiempos reales en hardware específico.</p>
  </section>

  <section>
    <h2>⚖️ 1.3 Caso medio</h2>
    <p>
      Comportamiento esperado ante entradas sin patrón específico.
    </p>
    <ul>
      <li>Describe ejecución típica considerando probabilidades.</li>
      <li>Importante para una visión más realista.</li>
    </ul>
    <p>
      <strong>Ejemplo:</strong> En ordenamiento por inserción, el caso promedio considera una lista aleatoria sin orden predefinido, con una complejidad de O(n²), mientras que el mejor caso (lista ya ordenada) es O(n).
    </p>
  </section>
</details>
<!---------------------------------------------------- SEMANA 3 --------------------------------------------------->
<details>
  <summary><h2>📌 SEMANA 3</h2></summary>
  <div>
    <p><h2>1.4. Caso peor</h2></p>
    <p>En el análisis de algoritmos el caso peor se refiere al escenario en el que un algoritmo realiza la mayor cantidad de operaciones posibles para una entrada de tamaño. Se analiza cuánto tiempo o cuántos recursos puede llegar a consumir el algoritmo en la situación más desfavorable</p>
    <p> <h3>Porque es importante?</h3></p>
    <ul>
        <li><p> GARANTÍA DE RENDIMIENTO: Permite asegurar que, sin importar la entrada, el algoritmo nunca será más lento que el tiempo calculado en el caso peor.</p></li>
        <li> COMPARACIÓN: Es útil para comparar algoritmos y elegir el más eficiente en situaciones críticas.</li>
        <br/>
        <p> EJEMPLO:
          En la búsqueda lineal, el caso peor ocurre cuando el elemento buscado está al final del arreglo o no existe, lo que implica recorrer todos los elementos.</p>
    </ul>
    <p><h3>Notación</h3></p>
    <p>Se utiliza la notación O grande (Big O) para expresar el crecimiento del tiempo de ejecución en el caso peor
      Ejemplo: La búsqueda lineal tiene un caso peor de O(n)
    </p>
  </div>

  <div>
       <p>
         <h2>1.5. Operación elemental</h2>
       </p>
      <p>
        Una operación elemental es la acción más básica y representativa que realiza un algoritmo y que se repite durante su ejecución. Es la unidad de medida que se utiliza para analizar el costo de un algoritmo.
      </p>
      <ul>
        <li>SIMPLICIDAD: Generalmente es una operación aritmética, una comparación, un acceso a memoria, etc.</li>
        <li>REPETICIÓN: Se elige la operación que más veces se repite en el algoritmo, ya que es la que más impacta en el tiempo total de ejecución.</li>
        <li>INDEPENDENCIA: Se asume que cada operación elemental toma un tiempo constante.</li>
      </ul>
      <p>EJEMPLO:
        En el algoritmo de búsqueda lineal, la operación elemental suele ser la comparación entre el elemento buscado y el elemento actual del arreglo.
      </p>
      <p>
        <h3>PORQUE ES IMPORTANTE?</h3>
        Permite cuantificar y comparar algoritmos de manera objetiva, sin depender del hardware o de implementaciones específicas.
      </p>
  </div>
</details>

<!---------------------------------------------------- SEMANA 4 --------------------------------------------------->
<details>
  <summary><h2>📌 SEMANA 4<h2></summary>
  <div>

## 2.1 Notación para el "orden de"

<p>La <strong>notación para el "orden de"</strong> en análisis de algoritmos se refiere principalmente a la notación Big-O (<em>O grande</em>), que es una herramienta matemática utilizada para describir cómo crece el tiempo de ejecución o el uso de recursos de un algoritmo en función del tamaño de la entrada.</p>

<p><strong>¿Qué expresa la notación Big-O?</strong></p>
<ul>
  <li>Expresa el <em>orden de crecimiento</em> de la función que representa el tiempo de ejecución o el espacio utilizado por un algoritmo, a medida que el tamaño de la entrada (n) tiende a infinito.</li>
  <li>Permite comparar la eficiencia de diferentes algoritmos, especialmente cuando se enfrentan a entradas muy grandes.</li>
</ul>

<p><strong>¿Cómo se utiliza?</strong></p>
<ul>
  <li>Se escribe como <code>O(f(n))</code>, donde <code>f(n)</code> es una función que describe cómo crecen los recursos requeridos en función de <code>n</code>.</li>
  <li>Por ejemplo, <code>O(1)</code> significa tiempo constante (no depende de <code>n</code>), <code>O(n)</code> es lineal, <code>O(n^2)</code> es cuadrático, y así sucesivamente.</li>
</ul>

<p><strong>Ejemplos de órdenes comunes:</strong></p>

<table>
  <thead>
    <tr>
      <th>Notación</th>
      <th>Nombre</th>
      <th>Ejemplo típico</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>O(1)</td>
      <td>Constante</td>
      <td>Acceso a un elemento en un array</td>
    </tr>
    <tr>
      <td>O(log n)</td>
      <td>Logarítmico</td>
      <td>Búsqueda binaria</td>
    </tr>
    <tr>
      <td>O(n)</td>
      <td>Lineal</td>
      <td>Recorrido de una lista</td>
    </tr>
    <tr>
      <td>O(n log n)</td>
      <td>Linealítmico</td>
      <td>Algoritmos de ordenamiento eficientes</td>
    </tr>
    <tr>
      <td>O(n^2)</td>
      <td>Cuadrático</td>
      <td>Algoritmos de ordenamiento simples</td>
    </tr>
    <tr>
      <td>O(2^n)</td>
      <td>Exponencial</td>
      <td>Algoritmos de fuerza bruta</td>
    </tr>
    <tr>
      <td>O(n!)</td>
      <td>Factorial</td>
      <td>Algoritmos de permutaciones</td>
    </tr>
  </tbody>
</table>

<p><strong>¿Por qué es útil?</strong></p>
<ul>
  <li>Simplifica el análisis ignorando constantes y términos de menor orden, enfocándose solo en el comportamiento dominante cuando <code>n</code> es grande.</li>
  <li>Ayuda a anticipar cómo escalará un algoritmo y a tomar decisiones informadas sobre cuál es más adecuado según el problema y el tamaño de los datos.</li>
</ul>

<p><strong>Reglas básicas al usar la notación Big-O:</strong></p>
<ul>
  <li>Se omiten constantes y términos de menor orden.</li>
  <li>Solo se considera el término de mayor crecimiento.</li>
</ul>

<p><strong>En resumen:</strong><br/>
La notación para el "orden de" (<em>O grande</em>) es fundamental para analizar, comparar y seleccionar algoritmos en computación, ya que permite describir de manera estandarizada y simplificada cómo crecen los recursos requeridos por un algoritmo en función del tamaño de la entrada.</p>

</div>
</details>

<!---------------------------------------------------- SEMANA 5 --------------------------------------------------->
<details>
  <summary><h2>📌 SEMANA 5</h2></summary>
  <div>
  
  ## 2.2 Notación Omega (Ω)
  
  <p>La <strong>notación Omega grande</strong> (Ω) se usa para establecer una <em>cota inferior asintótica</em> del tiempo de ejecución de un algoritmo. Es decir, indica que el algoritmo toma <em>por lo menos</em> cierta cantidad de tiempo para entradas suficientemente grandes.</p>
  
  <p>Formalmente, decimos que una función <code>f(n)</code> es <code>Ω(g(n))</code> si existen constantes positivas <code>c</code> y <code>n₀</code> tales que para todo <code>n ≥ n₀</code> se cumple:</p>
  
  \[ f(n) \geq c \cdot g(n) \]
  
  <p>Esto significa que <code>f(n)</code> crece al menos tan rápido como <code>g(n)</code> para valores grandes de <code>n</code>.</p>
  
  <p>La notación Ω es útil para describir el <em>mejor caso</em> o para dar una garantía mínima sobre el tiempo que un algoritmo necesitará.</p>
  
  <p>Por ejemplo, el tiempo de ejecución del peor caso de la búsqueda binaria es <code>Ω(1)</code>, porque al menos toma un tiempo constante.</p>
  
  ---
  
  ## 2.3 Notación Theta (Θ)
  
  <p>La <strong>notación Theta</strong> (Θ) se utiliza para expresar una <em>cota ajustada o estricta</em> del crecimiento de la función de tiempo de un algoritmo. Esto significa que la función está acotada tanto por arriba como por abajo por la misma función asintótica.</p>
  
  <p>Formalmente, <code>f(n)</code> es <code>Θ(g(n))</code> si existen constantes positivas <code>c₁, c₂</code> y <code>n₀</code> tales que para todo <code>n ≥ n₀</code>:</p>
  
  \[ c_1 \cdot g(n) \leq f(n) \leq c_2 \cdot g(n) \]
  
  <p>Esto implica que <code>f(n)</code> crece al mismo ritmo que <code>g(n)</code> para valores grandes de <code>n</code>.</p>
  
  <p>La notación Θ es la más precisa para describir la complejidad temporal o espacial de un algoritmo, ya que indica el comportamiento exacto en términos asintóticos.</p>
  
  ---
  
  ## 2.4 Notación asintótica condicional
  
  <p>La <strong>notación asintótica condicional</strong> se refiere a la aplicación de las notaciones asintóticas (O, Ω, Θ) bajo ciertas condiciones o restricciones sobre el tamaño de la entrada o parámetros específicos del problema.</p>
  
  <p>Por ejemplo, un algoritmo puede tener un comportamiento diferente según el rango o la forma de la entrada, y la notación condicional permite expresar estas diferencias.</p>
  
  <p>Un caso típico es cuando el análisis se hace para <em>n suficientemente grande</em>, o cuando se evalúa la complejidad solo para entradas que cumplen ciertas propiedades (como ser potencias de dos, o tener una estructura particular).</p>
  
  <p>Esta notación es útil para describir con mayor precisión el comportamiento de un algoritmo en situaciones específicas, y para ajustar las cotas asintóticas según condiciones particulares.</p>
  
  ---
  
  </div>

</details>


<!---------------------------------------------------- SEMANA 6 --------------------------------------------------->
<details>
  <summary><h2>📌 SEMANA 6</h2></summary>
      <div>
  
  ## 3.1 Estructuras de control
  
  <p>Las <strong>estructuras de control</strong> en programación son herramientas fundamentales que permiten controlar el flujo de ejecución de un programa o algoritmo. Gracias a ellas, el código puede seguir un flujo lógico, tomar decisiones, repetir acciones o continuar de forma secuencial, adaptándose a diferentes condiciones y situaciones.</p>
  
  <p>En esencia, las estructuras de control definen el orden en que se ejecutan las instrucciones dentro de un programa, permitiendo que éste no se limite a una ejecución lineal sino que pueda variar según las necesidades.</p>
  
  ---
  
  ### Tipos principales de estructuras de control
  
  <p>Las estructuras de control se clasifican en tres categorías básicas:</p>
  
  <ul>
    <li><strong>Estructuras secuenciales:</strong> Son las más simples, donde las instrucciones se ejecutan una tras otra en el orden en que están escritas. Este tipo de estructura es la base de cualquier algoritmo.</li>
    <li><strong>Estructuras condicionales o selectivas:</strong> Permiten que el programa tome decisiones y ejecute diferentes bloques de código según se cumplan o no ciertas condiciones. Ejemplos comunes son <code>if</code>, <code>else</code> y <code>switch</code>.</li>
    <li><strong>Estructuras iterativas o bucles:</strong> Permiten repetir un bloque de código varias veces, ya sea un número determinado de veces o mientras se cumpla una condición. Ejemplos son <code>for</code>, <code>while</code> y <code>do-while</code>.</li>
  </ul>
  
  ---
  
  ### Funciones y beneficios de las estructuras de control
  
  <ul>
    <li>Permiten que los programas respondan a diferentes condiciones y datos de entrada.</li>
    <li>Facilitan la repetición de tareas sin necesidad de duplicar código.</li>
    <li>Ayudan a modularizar y organizar el código, mejorando su legibilidad y mantenimiento.</li>
    <li>Son esenciales para la programación estructurada y el desarrollo de algoritmos eficientes.</li>
  </ul>
  
  ---

</details>
 

  <section>
    <h2>📚 Bibliografía</h2>
    <ul>
      <li>Etecé (2024). <em>Algoritmo en Informática</em>. Concepto. https://concepto.de/algoritmo-en-informatica/</li>
      <li>Wikipedia (2024). <em>Análisis de algoritmos</em>. https://es.wikipedia.org/wiki/An%C3%A1lisis_de_algoritmos</li>
      <li>Vega, A. <em>Algoritmia elemental</em>. Scribd. https://es.scribd.com/document/214313367/Tema2-Algoritmia-Elemental-Resumen</li>
      <li>Wikipedia (2024). <em>Contradicción</em>. https://es.wikipedia.org/wiki/Contradicci%C3%B3n</li>
      <li>Wikipedia (2024). <em>Inducción matemática</em>. https://es.wikipedia.org/wiki/Inducci%C3%B3n_matem%C3%A1tica</li>
      <li>Wikipedia (2022). <em>Casos peor, mejor y promedio</em>. https://es.wikipedia.org/wiki/Casos_peor,_mejor_y_promedio</li>
      <li>Wikipedia (2025). <em>Eficiencia algorítmica</em>. https://es.wikipedia.org/wiki/Eficiencia_algor%C3%ADtmica</li>
    </ul>
  </section>
</body>
</html>
