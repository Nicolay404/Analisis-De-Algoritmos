<h1 align="center"> AN√ÅLISIS DE ALGORITMOS <img src="https://media.giphy.com/media/hvRJCLFzcasrR4ia7z/giphy.gif" width="35"></h1>

<div align="center">
  <img src="https://media1.giphy.com/media/v1.Y2lkPTc5MGI3NjExcXN4aGx2ZjVnc2w5emJ2dXdyYm9panEwdWxmN2Z4dXZ4NDVwaGg5eSZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/78XCFBGOlS6keY1Bil/giphy.gif" width="300">
</div>

<h3></strong> <em>Diego Nicolay Jim√©nez Carri√≥n - üíé</em></h3>

<hr>

<div align="left">
  <p>
    ‚ñ∂Ô∏è El an√°lisis de algoritmos y la algoritmia son pilares fundamentales en el campo de la inform√°tica y la ciencia de la computaci√≥n. 
    Ambos conceptos se centran en el estudio de los algoritmos: secuencias ordenadas de pasos que permiten resolver problemas, 
    realizar tareas o efectuar c√°lculos de manera eficiente.
  </p>

  <p>
    üí® En esta wiki se abordar√°n de forma estructurada todos los temas relacionados con el an√°lisis de algoritmos, explorando desde 
    conceptos b√°sicos hasta t√©cnicas avanzadas. El objetivo es proporcionar una gu√≠a completa y accesible que facilite la comprensi√≥n 
    y aplicaci√≥n de los principios que sustentan este amplio y esencial campo de estudio. üëÄ
  </p>
</div>

<!-- INICIO DEL INDICE -->

<!-- FIN DEL INDICE --->

<!-- INICIO DEL CONTENIDO -->
  <h1>üìö ALGORITMOS Y AN√ÅLISIS</h1>

  <section>
    <h2>‚öôÔ∏è ¬øQu√© es un algoritmo?</h2>
    <p>
      Un <strong>algoritmo</strong> es un conjunto de instrucciones o reglas definidas para ejecutar alg√∫n c√°lculo, ya sea manualmente o mediante una m√°quina. Transforma un estado inicial y una entrada en un estado final mediante pasos sucesivos.
    </p>
    <blockquote>
      <strong>Ejemplo:</strong> Encender la luz de una habitaci√≥n.<br><br>
      ¬øLa luz est√° apagada?<br>
      <strong>NO:</strong> FIN<br>
      <strong>S√ç:</strong> Ve al paso 2<br>
      ‚Äî‚Äî<br>
      Presiona el interruptor y vuelve al paso 1.
    </blockquote>
    <p>
      Los algoritmos permiten la automatizaci√≥n digital moderna y son esenciales en disciplinas como las matem√°ticas, la inform√°tica y la l√≥gica. Por ejemplo, un algoritmo puede resolver problemas tan simples como ordenar una lista de n√∫meros o tan complejos como predecir el clima.
    </p>
  </section>

  <section>
    <h2>‚ú® Caracter√≠sticas</h2>
    <ul>
      <li><strong>üîÅ Secuenciales:</strong> Procesan paso a paso.</li>
      <li><strong>üéØ Precisos:</strong> Instrucciones claras y espec√≠ficas.</li>
      <li><strong>üßæ Ordenados:</strong> Se siguen en un orden l√≥gico.</li>
      <li><strong>‚õî Finitos:</strong> Tienen inicio y fin.</li>
      <li><strong>üìå Definidos:</strong> Mismos resultados con mismas entradas.</li>
    </ul>
  </section>

  <section>
    <h2>üß© Partes de un algoritmo</h2>
    <ul>
      <li><strong>üì• Entrada (Input):</strong> Instrucciones iniciales.</li>
      <li><strong>‚öôÔ∏è Proceso:</strong> Operaciones l√≥gicas.</li>
      <li><strong>üì§ Salida (Output):</strong> Resultados finales.</li>
    </ul>
<p align="center">  <img src="https://github.com/user-attachments/assets/8454721e-38df-4e67-83e6-b10d8117fa76" alt="Partes del algoritmo" width=300></p>

  </section>

  <section>
    <h2>üß† ALGORITMIA</h2>
    <p>
      La <strong>algoritmia</strong> estudia los algoritmos, enfoc√°ndose en su dise√±o, an√°lisis y aplicaci√≥n para resolver problemas de manera eficiente. Es una disciplina clave en inform√°tica que busca optimizar recursos computacionales.
    </p>
  <p align="center"> 
  <img src="https://github.com/user-attachments/assets/9020c530-f3e6-4f66-a0d6-f31eaa4123db" alt="Algoritmia"  width=300> </p>
  </section>

  <section>
    <h2>üîç An√°lisis de algoritmos</h2>
    <p>
      Estudia la <strong>complejidad computacional</strong>, estimando recursos como tiempo y almacenamiento. Permite comparar soluciones independientemente del lenguaje de programaci√≥n utilizado.
    </p>
    <h3>üìä Tipos de casos</h3>
    <ul>
      <li><strong>üü¢ Mejor caso:</strong> M√≠nimo n√∫mero de pasos.</li>
      <li><strong>üü° Caso promedio:</strong> Pasos esperados.</li>
      <li><strong>üî¥ Peor caso:</strong> M√°ximo n√∫mero de pasos.</li>
    </ul>

    
## üìä Complejidad Computacional

La **complejidad computacional** se refiere al an√°lisis del **tiempo** y **espacio** que requiere un algoritmo para ejecutarse. Esto implica medir los recursos que utiliza:

- ‚è≥ **Tiempo:** duraci√≥n de la ejecuci√≥n del algoritmo.  
- üíæ **Memoria:** cantidad de almacenamiento necesaria para completar el proceso.


---

### üìå Ejemplo Comparativo

| Algoritmo           | Pasos en promedio |
|---------------------|-------------------|
| üîç B√∫squeda lineal   | 28 pasos          |
| ‚ö° B√∫squeda binaria  | 5 pasos           |

---

Este an√°lisis es relevante porque permite **optimizar el rendimiento** de los algoritmos, asegurando que sean **m√°s r√°pidos** y **eficientes** en el uso de recursos. üöÄ

  </section>

  <section>
    <h2>üîé Tipos de an√°lisis</h2>
    <ul>
      <li><strong>‚è±Ô∏è Complejidad temporal:</strong> Relaci√≥n con el tama√±o de entrada.</li>
      <li><strong>üß† Complejidad espacial:</strong> Memoria usada.</li>
      <li><strong>‚úÖ Correctitud:</strong> Verifica salidas correctas.</li>
      <li><strong>üìà Asint√≥tico:</strong> Comportamiento con entradas grandes.</li>
    </ul>
  </section>
<br/>
<br/>
<h2> DESARROLLO DE CONTENIDOS</h2>
<!---------------------------------------------------- SEMANA 1 --------------------------------------------------->
<details>
  <summary><h2>üìå SEMANA 1</h2></summary>
  <h2>üå± 1. Algoritmia elemental</h2>
    <p>
      Introduce conceptos b√°sicos como eficiencia, an√°lisis de casos y algoritmos simples (b√∫squeda lineal, binaria, ordenamientos). Por ejemplo, la b√∫squeda lineal recorre todos los elementos hasta encontrar el objetivo, mientras que la b√∫squeda binaria divide el espacio de b√∫squeda a la mitad en cada paso, siendo m√°s eficiente en listas ordenadas.
    </p>
  </section>

  <section>
    <h2>üìå 1.1 Preliminares</h2>
    <ul>
      <li>Definici√≥n de algoritmo</li>
      <li>Representaci√≥n: pseudoc√≥digo, diagramas de flujo</li>
      <li>An√°lisis del problema, dise√±o y prueba</li>
    </ul>
  </section>

  <section>
    <h2>üî§ 1.1.1 Notaci√≥n</h2>
    <ul>
      <li><strong>O grande (O):</strong> Cota superior. Representa el peor caso de crecimiento, ignorando constantes y t√©rminos menores. Ejemplo: O(n¬≤) para un algoritmo que realiza operaciones cuadr√°ticas.</li>
      <li><strong>Omega (œâ):</strong> Cota inferior. Indica el mejor caso de crecimiento. Ejemplo: œâ(n) para un algoritmo que al menos recorre una lista una vez.</li>
      <li><strong>Theta (Œ∏):</strong> Cota ajustada. Describe un crecimiento exacto, combinando O y œâ. Ejemplo: Œ∏(n log n) para algoritmos como Quicksort en el caso promedio.</li>
    </ul>
   <p align="center">  <img src="https://i.ytimg.com/vi/Qui-iOPdhLI/maxresdefault.jpg" alt="Notaci√≥n asint√≥tica" width=400> </p>
  </section>

  <section>
    <h2>üö´ 1.1.2 Contradicci√≥n</h2>
    <p>
      T√©cnica para demostrar afirmaciones asumiendo lo contrario y llegando a un error l√≥gico. Por ejemplo, para demostrar que ‚àö2 es irracional, se asume que es racional (‚àö2 = a/b) y se llega a una contradicci√≥n al mostrar que a y b deben ser ambos pares, lo que es imposible.
    </p>
  </section>

  <section>
    <h2>üìê 1.1.3 Inducci√≥n matem√°tica</h2>
    <p>
      T√©cnica de prueba que utiliza un caso base y un paso inductivo. Ejemplo cl√°sico: Probar que <code>1 + 2 + ... + n = n(n+1)/2</code>.
    </p>
    <p>
      <strong>Caso base:</strong> Para n = 1, 1 = 1(1+1)/2 = 1. Se cumple.<br>
      <strong>Paso inductivo:</strong> Asumimos que es cierto para n = k, es decir, 1 + 2 + ... + k = k(k+1)/2. Para n = k+1, sumamos k+1 a ambos lados: 1 + 2 + ... + k + (k+1) = k(k+1)/2 + (k+1) = (k+1)(k+2)/2. Se cumple.<br>
      Por lo tanto, la f√≥rmula es v√°lida para todo n.
    </p>
  </section>
</details>
  <section>
    
<!---------------------------------------------------- SEMANA 2 --------------------------------------------------->
  <details>
  <summary><h2>üìå SEMANA 2</h2></summary>
   <section>
    <h2>‚ö° 1.2 Eficiencia de los algoritmos</h2>
    <ul>
      <li><strong>‚è≥ Tiempo de ejecuci√≥n:</strong> Operaciones seg√∫n entrada. Por ejemplo, un algoritmo O(n) tarda el doble si la entrada se duplica.</li>
      <li><strong>üíæ Uso de memoria:</strong> Variables, estructuras, temporales. Un algoritmo recursivo puede usar m√°s memoria debido a la pila de llamadas.</li>
      <li><strong>üìä Complejidad computacional:</strong> Representaci√≥n matem√°tica de la eficiencia, como O(log n) para b√∫squeda binaria.</li>
    </ul>
    <p><strong>M√©todos:</strong> Te√≥rico (matem√°tico) y emp√≠rico (con pruebas reales). El an√°lisis te√≥rico predice el comportamiento, mientras que el emp√≠rico mide tiempos reales en hardware espec√≠fico.</p>
  </section>

  <section>
    <h2>‚öñÔ∏è 1.3 Caso medio</h2>
    <p>
      Comportamiento esperado ante entradas sin patr√≥n espec√≠fico.
    </p>
    <ul>
      <li>Describe ejecuci√≥n t√≠pica considerando probabilidades.</li>
      <li>Importante para una visi√≥n m√°s realista.</li>
    </ul>
    <p>
      <strong>Ejemplo:</strong> En ordenamiento por inserci√≥n, el caso promedio considera una lista aleatoria sin orden predefinido, con una complejidad de O(n¬≤), mientras que el mejor caso (lista ya ordenada) es O(n).
    </p>
  </section>
</details>
<!---------------------------------------------------- SEMANA 3 --------------------------------------------------->
<details>
  <summary><h2>üìå SEMANA 3</h2></summary>
  <div>
    <p><h2>1.4. Caso peor</h2></p>
    <p>En el an√°lisis de algoritmos el caso peor se refiere al escenario en el que un algoritmo realiza la mayor cantidad de operaciones posibles para una entrada de tama√±o. Se analiza cu√°nto tiempo o cu√°ntos recursos puede llegar a consumir el algoritmo en la situaci√≥n m√°s desfavorable</p>
    <p> <h3>Porque es importante?</h3></p>
    <ul>
        <li><p> GARANT√çA DE RENDIMIENTO: Permite asegurar que, sin importar la entrada, el algoritmo nunca ser√° m√°s lento que el tiempo calculado en el caso peor.</p></li>
        <li> COMPARACI√ìN: Es √∫til para comparar algoritmos y elegir el m√°s eficiente en situaciones cr√≠ticas.</li>
        <br/>
        <p> EJEMPLO:
          En la b√∫squeda lineal, el caso peor ocurre cuando el elemento buscado est√° al final del arreglo o no existe, lo que implica recorrer todos los elementos.</p>
    </ul>
    <p><h3>Notaci√≥n</h3></p>
    <p>Se utiliza la notaci√≥n O grande (Big O) para expresar el crecimiento del tiempo de ejecuci√≥n en el caso peor
      Ejemplo: La b√∫squeda lineal tiene un caso peor de O(n)
    </p>
  </div>

  <div>
       <p>
         <h2>1.5. Operaci√≥n elemental</h2>
       </p>
      <p>
        Una operaci√≥n elemental es la acci√≥n m√°s b√°sica y representativa que realiza un algoritmo y que se repite durante su ejecuci√≥n. Es la unidad de medida que se utiliza para analizar el costo de un algoritmo.
      </p>
      <ul>
        <li>SIMPLICIDAD: Generalmente es una operaci√≥n aritm√©tica, una comparaci√≥n, un acceso a memoria, etc.</li>
        <li>REPETICI√ìN: Se elige la operaci√≥n que m√°s veces se repite en el algoritmo, ya que es la que m√°s impacta en el tiempo total de ejecuci√≥n.</li>
        <li>INDEPENDENCIA: Se asume que cada operaci√≥n elemental toma un tiempo constante.</li>
      </ul>
      <p>EJEMPLO:
        En el algoritmo de b√∫squeda lineal, la operaci√≥n elemental suele ser la comparaci√≥n entre el elemento buscado y el elemento actual del arreglo.
      </p>
      <p>
        <h3>PORQUE ES IMPORTANTE?</h3>
        Permite cuantificar y comparar algoritmos de manera objetiva, sin depender del hardware o de implementaciones espec√≠ficas.
      </p>
  </div>
</details>

<!---------------------------------------------------- SEMANA 4 --------------------------------------------------->
<details>
  <summary><h2>üìå SEMANA 4<h2></summary>
  <div>

## 2.1 Notaci√≥n para el "orden de"

<p>La <strong>notaci√≥n para el "orden de"</strong> en an√°lisis de algoritmos se refiere principalmente a la notaci√≥n Big-O (<em>O grande</em>), que es una herramienta matem√°tica utilizada para describir c√≥mo crece el tiempo de ejecuci√≥n o el uso de recursos de un algoritmo en funci√≥n del tama√±o de la entrada.</p>

<p><strong>¬øQu√© expresa la notaci√≥n Big-O?</strong></p>
<ul>
  <li>Expresa el <em>orden de crecimiento</em> de la funci√≥n que representa el tiempo de ejecuci√≥n o el espacio utilizado por un algoritmo, a medida que el tama√±o de la entrada (n) tiende a infinito.</li>
  <li>Permite comparar la eficiencia de diferentes algoritmos, especialmente cuando se enfrentan a entradas muy grandes.</li>
</ul>

<p><strong>¬øC√≥mo se utiliza?</strong></p>
<ul>
  <li>Se escribe como <code>O(f(n))</code>, donde <code>f(n)</code> es una funci√≥n que describe c√≥mo crecen los recursos requeridos en funci√≥n de <code>n</code>.</li>
  <li>Por ejemplo, <code>O(1)</code> significa tiempo constante (no depende de <code>n</code>), <code>O(n)</code> es lineal, <code>O(n^2)</code> es cuadr√°tico, y as√≠ sucesivamente.</li>
</ul>

<p><strong>Ejemplos de √≥rdenes comunes:</strong></p>

<table>
  <thead>
    <tr>
      <th>Notaci√≥n</th>
      <th>Nombre</th>
      <th>Ejemplo t√≠pico</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>O(1)</td>
      <td>Constante</td>
      <td>Acceso a un elemento en un array</td>
    </tr>
    <tr>
      <td>O(log n)</td>
      <td>Logar√≠tmico</td>
      <td>B√∫squeda binaria</td>
    </tr>
    <tr>
      <td>O(n)</td>
      <td>Lineal</td>
      <td>Recorrido de una lista</td>
    </tr>
    <tr>
      <td>O(n log n)</td>
      <td>Lineal√≠tmico</td>
      <td>Algoritmos de ordenamiento eficientes</td>
    </tr>
    <tr>
      <td>O(n^2)</td>
      <td>Cuadr√°tico</td>
      <td>Algoritmos de ordenamiento simples</td>
    </tr>
    <tr>
      <td>O(2^n)</td>
      <td>Exponencial</td>
      <td>Algoritmos de fuerza bruta</td>
    </tr>
    <tr>
      <td>O(n!)</td>
      <td>Factorial</td>
      <td>Algoritmos de permutaciones</td>
    </tr>
  </tbody>
</table>

<p><strong>¬øPor qu√© es √∫til?</strong></p>
<ul>
  <li>Simplifica el an√°lisis ignorando constantes y t√©rminos de menor orden, enfoc√°ndose solo en el comportamiento dominante cuando <code>n</code> es grande.</li>
  <li>Ayuda a anticipar c√≥mo escalar√° un algoritmo y a tomar decisiones informadas sobre cu√°l es m√°s adecuado seg√∫n el problema y el tama√±o de los datos.</li>
</ul>

<p><strong>Reglas b√°sicas al usar la notaci√≥n Big-O:</strong></p>
<ul>
  <li>Se omiten constantes y t√©rminos de menor orden.</li>
  <li>Solo se considera el t√©rmino de mayor crecimiento.</li>
</ul>

<p><strong>En resumen:</strong><br/>
La notaci√≥n para el "orden de" (<em>O grande</em>) es fundamental para analizar, comparar y seleccionar algoritmos en computaci√≥n, ya que permite describir de manera estandarizada y simplificada c√≥mo crecen los recursos requeridos por un algoritmo en funci√≥n del tama√±o de la entrada.</p>

</div>
</details>

<!---------------------------------------------------- SEMANA 5 --------------------------------------------------->
<details>
  <summary><h2>üìå SEMANA 5</h2></summary>
  <div>
  
  ## 2.2 Notaci√≥n Omega (Œ©)
  
  <p>La <strong>notaci√≥n Omega grande</strong> (Œ©) se usa para establecer una <em>cota inferior asint√≥tica</em> del tiempo de ejecuci√≥n de un algoritmo. Es decir, indica que el algoritmo toma <em>por lo menos</em> cierta cantidad de tiempo para entradas suficientemente grandes.</p>
  
  <p>Formalmente, decimos que una funci√≥n <code>f(n)</code> es <code>Œ©(g(n))</code> si existen constantes positivas <code>c</code> y <code>n‚ÇÄ</code> tales que para todo <code>n ‚â• n‚ÇÄ</code> se cumple:</p>
  
  \[ f(n) \geq c \cdot g(n) \]
  
  <p>Esto significa que <code>f(n)</code> crece al menos tan r√°pido como <code>g(n)</code> para valores grandes de <code>n</code>.</p>
  
  <p>La notaci√≥n Œ© es √∫til para describir el <em>mejor caso</em> o para dar una garant√≠a m√≠nima sobre el tiempo que un algoritmo necesitar√°.</p>
  
  <p>Por ejemplo, el tiempo de ejecuci√≥n del peor caso de la b√∫squeda binaria es <code>Œ©(1)</code>, porque al menos toma un tiempo constante.</p>
  
  ---
  
  ## 2.3 Notaci√≥n Theta (Œò)
  
  <p>La <strong>notaci√≥n Theta</strong> (Œò) se utiliza para expresar una <em>cota ajustada o estricta</em> del crecimiento de la funci√≥n de tiempo de un algoritmo. Esto significa que la funci√≥n est√° acotada tanto por arriba como por abajo por la misma funci√≥n asint√≥tica.</p>
  
  <p>Formalmente, <code>f(n)</code> es <code>Œò(g(n))</code> si existen constantes positivas <code>c‚ÇÅ, c‚ÇÇ</code> y <code>n‚ÇÄ</code> tales que para todo <code>n ‚â• n‚ÇÄ</code>:</p>
  
  \[ c_1 \cdot g(n) \leq f(n) \leq c_2 \cdot g(n) \]
  
  <p>Esto implica que <code>f(n)</code> crece al mismo ritmo que <code>g(n)</code> para valores grandes de <code>n</code>.</p>
  
  <p>La notaci√≥n Œò es la m√°s precisa para describir la complejidad temporal o espacial de un algoritmo, ya que indica el comportamiento exacto en t√©rminos asint√≥ticos.</p>
  
  ---
  
  ## 2.4 Notaci√≥n asint√≥tica condicional
  
  <p>La <strong>notaci√≥n asint√≥tica condicional</strong> se refiere a la aplicaci√≥n de las notaciones asint√≥ticas (O, Œ©, Œò) bajo ciertas condiciones o restricciones sobre el tama√±o de la entrada o par√°metros espec√≠ficos del problema.</p>
  
  <p>Por ejemplo, un algoritmo puede tener un comportamiento diferente seg√∫n el rango o la forma de la entrada, y la notaci√≥n condicional permite expresar estas diferencias.</p>
  
  <p>Un caso t√≠pico es cuando el an√°lisis se hace para <em>n suficientemente grande</em>, o cuando se eval√∫a la complejidad solo para entradas que cumplen ciertas propiedades (como ser potencias de dos, o tener una estructura particular).</p>
  
  <p>Esta notaci√≥n es √∫til para describir con mayor precisi√≥n el comportamiento de un algoritmo en situaciones espec√≠ficas, y para ajustar las cotas asint√≥ticas seg√∫n condiciones particulares.</p>
  
  ---
  
  </div>

</details>


<!---------------------------------------------------- SEMANA 6 --------------------------------------------------->
<details>
  <summary><h2>üìå SEMANA 6</h2></summary>
      <div>
  
  ## 3.1 Estructuras de control
  
  <p>Las <strong>estructuras de control</strong> en programaci√≥n son herramientas fundamentales que permiten controlar el flujo de ejecuci√≥n de un programa o algoritmo. Gracias a ellas, el c√≥digo puede seguir un flujo l√≥gico, tomar decisiones, repetir acciones o continuar de forma secuencial, adapt√°ndose a diferentes condiciones y situaciones.</p>
  
  <p>En esencia, las estructuras de control definen el orden en que se ejecutan las instrucciones dentro de un programa, permitiendo que √©ste no se limite a una ejecuci√≥n lineal sino que pueda variar seg√∫n las necesidades.</p>
  
  ---
  
  ### Tipos principales de estructuras de control
  
  <p>Las estructuras de control se clasifican en tres categor√≠as b√°sicas:</p>
  
  <ul>
    <li><strong>Estructuras secuenciales:</strong> Son las m√°s simples, donde las instrucciones se ejecutan una tras otra en el orden en que est√°n escritas. Este tipo de estructura es la base de cualquier algoritmo.</li>
    <li><strong>Estructuras condicionales o selectivas:</strong> Permiten que el programa tome decisiones y ejecute diferentes bloques de c√≥digo seg√∫n se cumplan o no ciertas condiciones. Ejemplos comunes son <code>if</code>, <code>else</code> y <code>switch</code>.</li>
    <li><strong>Estructuras iterativas o bucles:</strong> Permiten repetir un bloque de c√≥digo varias veces, ya sea un n√∫mero determinado de veces o mientras se cumpla una condici√≥n. Ejemplos son <code>for</code>, <code>while</code> y <code>do-while</code>.</li>
  </ul>
  
  ---
  
  ### Funciones y beneficios de las estructuras de control
  
  <ul>
    <li>Permiten que los programas respondan a diferentes condiciones y datos de entrada.</li>
    <li>Facilitan la repetici√≥n de tareas sin necesidad de duplicar c√≥digo.</li>
    <li>Ayudan a modularizar y organizar el c√≥digo, mejorando su legibilidad y mantenimiento.</li>
    <li>Son esenciales para la programaci√≥n estructurada y el desarrollo de algoritmos eficientes.</li>
  </ul>
  
  ---

</details>
 

  <section>
    <h2>üìö Bibliograf√≠a</h2>
    <ul>
      <li>Etec√© (2024). <em>Algoritmo en Inform√°tica</em>. Concepto. https://concepto.de/algoritmo-en-informatica/</li>
      <li>Wikipedia (2024). <em>An√°lisis de algoritmos</em>. https://es.wikipedia.org/wiki/An%C3%A1lisis_de_algoritmos</li>
      <li>Vega, A. <em>Algoritmia elemental</em>. Scribd. https://es.scribd.com/document/214313367/Tema2-Algoritmia-Elemental-Resumen</li>
      <li>Wikipedia (2024). <em>Contradicci√≥n</em>. https://es.wikipedia.org/wiki/Contradicci%C3%B3n</li>
      <li>Wikipedia (2024). <em>Inducci√≥n matem√°tica</em>. https://es.wikipedia.org/wiki/Inducci%C3%B3n_matem%C3%A1tica</li>
      <li>Wikipedia (2022). <em>Casos peor, mejor y promedio</em>. https://es.wikipedia.org/wiki/Casos_peor,_mejor_y_promedio</li>
      <li>Wikipedia (2025). <em>Eficiencia algor√≠tmica</em>. https://es.wikipedia.org/wiki/Eficiencia_algor%C3%ADtmica</li>
    </ul>
  </section>
</body>
</html>
